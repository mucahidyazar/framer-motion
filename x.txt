Variants
•	Variantslar bizi kod tekrarindan kurtaran framer motion yapilaridir.
•	Ilk once asagidaki gibi bir variants adinda veya farkli adda bir degiskeni obje olarak tanimliyoruz ve icerisine istedigimiz isimlerde object key isimleri belirleyebiliyoruz. Ben accordion yapim icin open ve closed kullandim. Daha sorna bu keylere value olarak, initial, animate veya exitte kullandigimiz gibi degerleri veriyoruz.
•	Daha sonra bu tanimladigimiz objeyi variants props u olarak motion’a veriyoruz.
•	Ve daha sonra asagidaki gibi initial, animate veya exit icin tek yapmamiz gereken variants propsuna verdigimzi objedeki key isimlerini string olarak vermek.
•	Ve tadaaa animasyonumuz halen eskisi gibi calisiyor. Hem daha okunakli hemde daha Pratik.

•	Elimizde asagidaki gibi bir menumuz var. Burada Headerin yanindaki logoya basinca sayfayi kaplayan, sayfaya soldan giren bir menu tasarlamak istiyoruz.
•	Buradaki gibi. Ama sayfayi tam kaplayacak 100vw 100vh yani.


Styled-components ile birlikte kullanmak
•	Framer-motionu istersek styled-components ile birliktede kullanabiliriz. Bu sekilde kullanmak icin styled.div yapmak yerine styled’a argument olarak motion.div yapariz. Asagida ornek olarak bir Nav elemaninin bir styled components ile birde motion-framer ile birlikte yapilisini ornek olarak birakiyorum.
•	Asagiya ana App.js imi ayarliyorum.
•	Menuye onClick veriyorum ki Headerin yanindaki logoya tiklayinca state degissin ve o stateye gore menu acilsin.
•	Buradada menu cvomponentim bulunuyor. {…props} yaparak onClick’I dive atiyorum aslinda.

•	Ve son olarak da burada Nav componentim bulunuyor.
•	Burada Nav’in kapali oldugunda, DOM’dan tamamen kaldirilmis sekilde olmasini istemedigim icin AnimatePresence Wrapperini kullanmiyorum. Onun yerine animate’e isNavOpen statesine gore vatiantdaki open veya closed olmasini istiyorum. Yani sadece opacitysi olmuyor kapali oldugunda ama her  zaman domda bulunuyor.
•	Ayrica asagida gordugunuz uzere her animate, initial ve exit durumlari icin transition ozelligini iclerindede istersem tanimlayabiliyorum.
•	Istersem hem Menu Nav icin hemde motion.li le ricin ayni variant kullanabilirdim. Fakat burada ayri varianlar kullandim. Bu sayede motion.li lerin ayri animationlara sahip olmasini sagladim. Eger kullanmasaydim motion.li ler MenuNavla beraber ayni animationlari uygulayacaklardi.
•	Peki niye farkli animasyonlar uyguladik bu animasyonlar bize ne saglayacak. Asagida liVariant yani motion.li’ye verdigimiz variantdaki open’da .3 saniye delay yan’ gec’kme var. Openla birlikte hemen animasyonu calisan MenuNav acilir ve daha sonra liVariants daki .3 yani 0.3 saniye gecikmeyle Navdaki linin, liVariants daki open calisir. Yani kisaca bu delay sadece linkler icin uygulanir ve bu sayede bizim linklerimiz MenuNav geldikten 0.3 saniye sonra ekrana animasyonlu bir sekilde giris yapar.
•	Ve variantsdada bir .3 saniye gecikme var gordugunuz gibi. Buda closed animation calistiginda, bizim linklerimizde delay olmadigi icin hemen cikis yaparlar. Fakat variantsda MenuNav icin bir gecikme oldugu icin MenuNav komponenti 0.3 saniye gecikmeyle animasyonlari calisarak yok olur.



staggerChildren & delayChildren & staggerDirection & when
•	Transition ve delayi liVariants lardan kaldiriyoruz. Ve ul variants olusturuyoruz. Ve jsx deki ul’yide motion.ul seklinde yapiyoruz
•	Ve ul’e open calistiginda scale 1.05 yapiyoruz bu tum ul ve icindekileri 1.05 kadar buyutecektir. Closedda da tekrar 1 olsun diyoruz yani normal boyutlari
•	Transition tanimliyoruz.
o	staggerChildren diyerek 0.5 diyoruz. Bu bize ul nin icindeki nav linki li elemanlarinin yani childrenlarinin 0.5 saniye araliklarla sirayla sahneye animasyonlu sekilde girmesini sagliyor.
o	delayChildren tum childrenlarin gecikme suresidir. Burada 2 saniye demisiz yani childrenlarin sirayla girmeye baslamasi, ul open olduktan 2 saniye sonra gerceklesecektir.
o	straggerDirection ise ya 1 olur default degeridir. Yada -1 olur. -1 yaparsak normalde en usttekinden basliyarak giriyorsa sahneye bu sefer ul icindeki li elemanlarinin en sonundakinden baslayarak sahneye girecegi icin tersten bir animasyon efektini baslatmis oluruz ul icindeki li le ricin.
o	When ise ya afterChildren yada beforeChildren olur. Peki bu ne icin. When transition icinde yazildigi icin, Transition disindaki diger animationlarin, transitiondaki animasyonlardan sonra calismasini saglar. Yani afterChildren ile ilk once transition icindeki animasyonlar calisir ulde daha sonra scale calisarak 1.05 buyutme uygular. BeforeChildren olsaydi 1.05 buyutme uygulardi ve daha sonra transitiondaki animasyonlar calisirdi.


GESTURES
•	Gesturesler motion-framer’in fakeyle uzerinde gezme, dokunma, kaydirma, surukleme hareket izleyicileri ve olay dinleyicileridir. Bunlar bize yardimci ozelliklerdir diyebiliriz.

•	whileHover hover oldugumuz zaman olacak framer efektlerini tanimlariz.
•	whileTap, Card elementine dokundugumuzda gerceklesecek efekt ve animasyonlardir.
•	onHoverEnd motion framerin bize verdigi eventdir. Mouse ile hoverdan ciktigimizda calisacakdir.


drag && dragConstraints
•	drag verdigimiz elementi drag edilebilir yani suruklenebilir hale getiriyor.
•	dragConstraints ise verdigimiz elementin browserdaki windows size’ina gore limitler belirliyor. Ornegin asagida Card elementinin maksimum top yani ust kisimda 100px’e kadar suruklenebilir. Siz mouse ile disariya suruklesenizde, biraktiginizda o geriye donup toptan 100 px asagiya gelecektir.
•	drag’a istersek x veya y stringi verebiliriz bu sayede suruklenebilirligi x veya y ekseniyle sinirlayabiliriz.
•	Asagida element dragini dragda x ekseninde sinirlandiriyoruz, daha sonra dragConstraints ilede left ve right kisimlardan disariya cikmamasi icin ayrica birdaha sinirlandiriyoruz. Bu sayede itemimiz saga ve sola surtuklenebiliyor ve ayrica width den disariyada cikamiyor olacak.


useMotionValue & useTransform
•	x ve opacity constant larinin ciktisi asagidaki resimdeki gibidir.
•	useMotionValue ile initiali 0 olan bir argument veriyoruz ve takip edilebilen bir x yapiyoruz.
•	Daha sonra da useTransform yaparak takip edilen useMotionValueyi burada useTransfrom’da ilk argument olarak veriyoruz, ikincxi argument olarakda kordinatlari veriyoruz ve 3. Argument olarakda 2. Argumentde verdigimiz kordinatlarda hangi ozelliklerde olmasini istiyoruz. Opacity’e bu degiskeni verecegimiz icin opacity nin Kabul ettigi 0 ve 1 I kullanarak, -200 icin yani soladogru kaydirildiginda 0(opacity 0 olacak ayni sola kaydirildikca yok olacak), ortadayken yani 0 da initialdayken opacity 1 olacak ve 200 deyken yani saga kaydirildigindada opacity 0 olacak ve yine yok olacak seklinde ayarliyoruz.

Saga Kaydirinca Yok Olmasini Saglamak
•	Yukarida ki ornekte hazirladigimiz x ekseninde hareket eden karti saga kaydirilinca yok olmasini saglamak istiyoruz asagidaki gibi.


onDragEnd
•	Sadece opacity 0 olmayacagi ayni zamanda DOM’dan da silinmesini istedigimiz icin AnimatePresence wrapperimizida import edecegiz.
•	Resime tiklayip saga kaydirdigimiz zaman aslinda bir drag eventi olusturmus oluyoruz ve biz bu dragin sonunda eger kartimiz belirledigimiz 200px kadar saga veya sola acildiysa kartin silinmesini istiyoruz. Bunun icin exit eventi ayarlamamiz gerekiyor.
•	Exit eventini bir state’de tutacagim. State isCardVisible. Ne zaman ki Card’in x degeri 200 veya -200 olursa bu stateyi false yapacagim ve exit animasyonu calisacak. Fakat exit animationunu Card’a uygulayamam cunku eger Carda exit animation uygularsak, Card saga surukleme eventi bittiginde tekrar geri merkeze donme animasyonu calisip daha sonra silinme animasyonu exit ile calisacagi icin asagida ki gibi bir bug ile karsilasiriz.
•	Bu sorunu cozmek icin ekstra bir motion.div ile Wrap ediyoruz cevresini ve exit animationumuzu burada tanimliyoruz.
•	Peki Card’in x ekseninde 200 saga veya sola acildigini nasil anliyor ve takip ediyoruz. onDragEnd eventi 2 parametre veriyor bize. Event ve info. Event tetiklendiginde Info.point x ve y keylerini ve valuelarini donuyor bize. Burada ki x ve y belirledigimiz 0 yani merkeze uzakliklarini soyler. Merkezi pointi farkli soyleseydik ona gore deger donecek ve hareket edecekti.

Shuffle Component

•	Bu ornegimizde asagidaki gibi bir component olusturacagiz ve shuffle butonuna tikladigimizda icindeki renkli kutulu divler, her seferinde karisip farkli siralanacaklar.

•	Bu ornegimizde lodash kullanacagimiz icin lodashida asagida ki gibi yukluyoruz.
npm install --save lodash


Layout
•	Layout ozelligi verdigimiz elementin otomatik animasyon kazanmasini saglar. Diyelim bir butona tikladigimizda kutu sayfanin en ustunden en altina gidecek. Kutu div oldugunu var sayalim. Normalde tikladigimizda en ustten en alta birden animasyonsuz keskin bir sekilde gecer. Fakat div’I motion.div’e cevirdikten sonra layout props unu verirsek eger artik kutu yaptigi o islemi framer-motion un default animation ozellikleriyle yapar. Isterseniz tabi ayarlarini control edebilrisiniz.

•	Bir state olusturuyoruz ve bu stateye colorslarimizin oldugu arrayi veriyoruz ve bu stateyi .map ile return ederken mapden gelen elemanlari motion.div ile return ediyoruz.
•	Ve her bir motion.div ayni zamanda da keye sahip olmali yoksa shuffle calismaz cunku onlari taniyamaz.
•	Lodash’dan shuffle methodunu import ediyoruz. Bu array elemanlarini karistirip tekrar array donen bir method.
•	Ve her bir motion.div layout propsuna sahip olmali yoksa event animation calismaz. Burda karistirilirken gozumuze soft ve animasyonlu gelmesini saglayan motion-framer ozelligi layout propsudur.
•	Ve is terseniz transition ozellikleri belirleyip daha dampingli efektlerde verebilrisiniz.


SlideShow Project
•	@popmotion/popcorn’dan aldigimiz wrap method 1 tane min sayi, 1 tane max sayi ve guncel sayi argumentlerini alir. Ve guncel sayi max sayiyi gecerse, guncel sayi – max sayi arasidnaki farki doner. Farkida gecerse farki – max sayi farkini doner. Bu bizim sliderimizda son renge geldikten sonra en basa donmemizi saglayacak fonksiyonalityi olusturacak.
•	State [[page, direction], setPage] seklinde tanimlamamizin sebebi, page aslinda hangi resim oldugudur, direction ise sagdaki resmi gormek icin resmi sola surukledigimizde veya sag ok buttonuna tiklayip resmi degistirdigimizde direction +1 olacakdir cunku 1 sonraki resmi istiyoruz, digger turlusude -1 olacakdir cunku bir onceki resmi slide I istiyoruz.
•	Tanimladigimiz paginate functionuylada butona tikladigimizda veya drag yaparkenki x konumuna gore page ve direction set ediyoruz.

custom
•	Custom ile default olarak variantslara props gonderebiliriz. AnimatePresence ve motion’a verdigimiz sayesinde bunlari variantsda asagida gordugunuz gibi yakalayabilir ve bunlara gore dynamic degerler verebiliriz.
•	AnimatePresence ve motion.div e ayni anda custom vermemizin sebebi motion child component oldugu icin ilk seferinde customdan gonderdigimiz directionu dogru yakalayamiyor bu yuzden parentinada veriyoruz ki motion duzgun bir sekilde ilk seferindede yakalayabilsin.
•	Burda godnerdigimiz direction ya 1 yada -1. Yukarida anlatmistim zaten. Enter olunca resim soldan girecegi sekilde bir animasyon veriyoruz, ve surukledigimiz resimde exit olunca onun icinde bir baska animasyon ayarliyoruz ve bu ikisinin beraber calismasiyla cok guzel bir slide efekti yakaliyoruz. Mutlaka bu kismi deneyerek gorun.



dragElastic
•	dragElastic suruklenen itemlerin daha hizli ve rahat suruklenmesini saglar normalde biraz yavas ve zor suruklenirler.


Layout
•	Layout ozelligi verdigimiz elementin otomatik animasyon kazanmasini saglar. Diyelim bir butona tikladigimizda kutu sayfanin en ustunden en altina gidecek. Kutu div oldugunu var sayalim. Normalde tikladigimizda en ustten en alta birden animasyonsuz keskin bir sekilde gecer. Fakat div’I motion.div’e cevirdikten sonra layout props unu verirsek eger artik kutu yaptigi o islemi framer-motion un default animation ozellikleriyle yapar. Isterseniz tabi ayarlarini control edebilrisiniz.

•	Asagida header adinda bir elementimiz var. y nin scroll degerine gore animate calistiriyor.
•	Icindeki h1 ise layout propsu almis. Motion.header y nin scroll position 20 den buyukse yani 20px asagi scroll edilmisse justify-contenti center yaparak h1 I ortaliyor. Framer-motion layout gorunce anliyor ve burada devreye girerek soldan ortaya gecen yolda h1’e animasyon vererek center yaptiriyor.


Layout Scale Correction
•	Asagidaki kod acilir kapanir bir accordiondur asagidaki resimdeki gibi.


AnimateSharedLayout & layoutId
•	AnimatedSharedLayout icine layoutId lerle elementlerimizi birbirleriyle iliskilendirebiliriz.
•	Ayrica layout kullandiginiz yerde layoutId kullanacaksaniz layout u silip sadece layoutId de kullanabilirsiniz.

•	2 tane farklı elemente aynı layoutId lerı vererek bırbırlerıyle baglantılı olmasını isteriz. Mesela asagıda Level Up Tutorıals yazıyor loading ekranında. Bu aslında koddakı motion.h3. Ve ayni zamanda Header kisminda motion.h1 ile yine Level Up Tutorials yazan bir element tanimlamisiz. Bunlarin layoutId leri ayni oldugu icin loading ekrani kapanirken, loading ekranindaki h3, headerdaki h1e animasyonlu bir sekilde kayarak donusur asagidaki gibi.
